// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.220531.1

#pragma once
#ifndef WINRT_Microsoft_Graphics_Canvas_Geometry_H
#define WINRT_Microsoft_Graphics_Canvas_Geometry_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.220531.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.220531.1"
#include "winrt/Microsoft.Graphics.Canvas.h"
#include "winrt/impl/Microsoft.Graphics.Canvas.2.h"
#include "winrt/impl/Microsoft.Graphics.Canvas.Text.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Numerics.2.h"
#include "winrt/impl/Windows.Graphics.2.h"
#include "winrt/impl/Microsoft.Graphics.Canvas.Geometry.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasCachedGeometry<D>::Device() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometry)->get_Device(&value));
        return winrt::Microsoft::Graphics::Canvas::CanvasDevice{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasCachedGeometryStatics<D>::CreateFill(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry) const
    {
        void* cachedGeometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics)->CreateFill(*(void**)(&geometry), &cachedGeometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry{ cachedGeometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasCachedGeometryStatics<D>::CreateFill(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float flatteningTolerance) const
    {
        void* cachedGeometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics)->CreateFillWithFlatteningTolerance(*(void**)(&geometry), flatteningTolerance, &cachedGeometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry{ cachedGeometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasCachedGeometryStatics<D>::CreateStroke(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float strokeWidth) const
    {
        void* cachedGeometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics)->CreateStroke(*(void**)(&geometry), strokeWidth, &cachedGeometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry{ cachedGeometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasCachedGeometryStatics<D>::CreateStroke(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        void* cachedGeometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics)->CreateStrokeWithStrokeStyle(*(void**)(&geometry), strokeWidth, *(void**)(&strokeStyle), &cachedGeometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry{ cachedGeometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasCachedGeometryStatics<D>::CreateStroke(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle, float flatteningTolerance) const
    {
        void* cachedGeometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics)->CreateStrokeWithStrokeStyleAndFlatteningTolerance(*(void**)(&geometry), strokeWidth, *(void**)(&strokeStyle), flatteningTolerance, &cachedGeometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry{ cachedGeometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::CombineWith(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& otherGeometry, winrt::Windows::Foundation::Numerics::float3x2 const& otherGeometryTransform, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometryCombine const& combine) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->CombineWith(*(void**)(&otherGeometry), impl::bind_in(otherGeometryTransform), static_cast<int32_t>(combine), &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::CombineWith(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& otherGeometry, winrt::Windows::Foundation::Numerics::float3x2 const& otherGeometryTransform, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometryCombine const& combine, float flatteningTolerance) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->CombineWithUsingFlatteningTolerance(*(void**)(&otherGeometry), impl::bind_in(otherGeometryTransform), static_cast<int32_t>(combine), flatteningTolerance, &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Stroke(float strokeWidth) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->Stroke(strokeWidth, &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Stroke(float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->StrokeWithStrokeStyle(strokeWidth, *(void**)(&strokeStyle), &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Stroke(float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle, winrt::Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->StrokeWithAllOptions(strokeWidth, *(void**)(&strokeStyle), impl::bind_in(transform), flatteningTolerance, &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Outline() const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->Outline(&geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Outline(winrt::Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->OutlineWithTransformAndFlatteningTolerance(impl::bind_in(transform), flatteningTolerance, &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Simplify(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometrySimplification const& simplification) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->Simplify(static_cast<int32_t>(simplification), &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Simplify(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometrySimplification const& simplification, winrt::Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->SimplifyWithTransformAndFlatteningTolerance(static_cast<int32_t>(simplification), impl::bind_in(transform), flatteningTolerance, &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Transform(winrt::Windows::Foundation::Numerics::float3x2 const& transform) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->Transform(impl::bind_in(transform), &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::CompareWith(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& otherGeometry) const
    {
        winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometryRelation relation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->CompareWith(*(void**)(&otherGeometry), reinterpret_cast<int32_t*>(&relation)));
        return relation;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::CompareWith(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& otherGeometry, winrt::Windows::Foundation::Numerics::float3x2 const& otherGeometryTransform, float flatteningTolerance) const
    {
        winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometryRelation relation{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->CompareWithUsingTransformAndFlatteningTolerance(*(void**)(&otherGeometry), impl::bind_in(otherGeometryTransform), flatteningTolerance, reinterpret_cast<int32_t*>(&relation)));
        return relation;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputeArea() const
    {
        float area{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputeArea(&area));
        return area;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputeArea(winrt::Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
    {
        float area{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputeAreaWithTransformAndFlatteningTolerance(impl::bind_in(transform), flatteningTolerance, &area));
        return area;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputePathLength() const
    {
        float length{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputePathLength(&length));
        return length;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputePathLength(winrt::Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
    {
        float length{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputePathLengthWithTransformAndFlatteningTolerance(impl::bind_in(transform), flatteningTolerance, &length));
        return length;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputePointOnPath(float distance) const
    {
        winrt::Windows::Foundation::Numerics::float2 point{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputePointOnPath(distance, put_abi(point)));
        return point;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputePointOnPath(float distance, winrt::Windows::Foundation::Numerics::float2& tangent) const
    {
        winrt::Windows::Foundation::Numerics::float2 point{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputePointOnPathWithTangent(distance, impl::bind_out(tangent), put_abi(point)));
        return point;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputePointOnPath(float length, winrt::Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance, winrt::Windows::Foundation::Numerics::float2& tangent) const
    {
        winrt::Windows::Foundation::Numerics::float2 point{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputePointOnPathWithTransformAndFlatteningToleranceAndTangent(length, impl::bind_in(transform), flatteningTolerance, impl::bind_out(tangent), put_abi(point)));
        return point;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::FillContainsPoint(winrt::Windows::Foundation::Numerics::float2 const& point) const
    {
        bool containsPoint{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->FillContainsPoint(impl::bind_in(point), &containsPoint));
        return containsPoint;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::FillContainsPoint(winrt::Windows::Foundation::Numerics::float2 const& point, winrt::Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
    {
        bool containsPoint{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->FillContainsPointWithTransformAndFlatteningTolerance(impl::bind_in(point), impl::bind_in(transform), flatteningTolerance, &containsPoint));
        return containsPoint;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputeBounds() const
    {
        winrt::Windows::Foundation::Rect bounds{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputeBounds(put_abi(bounds)));
        return bounds;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputeBounds(winrt::Windows::Foundation::Numerics::float3x2 const& transform) const
    {
        winrt::Windows::Foundation::Rect bounds{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputeBoundsWithTransform(impl::bind_in(transform), put_abi(bounds)));
        return bounds;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputeStrokeBounds(float strokeWidth) const
    {
        winrt::Windows::Foundation::Rect bounds{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputeStrokeBounds(strokeWidth, put_abi(bounds)));
        return bounds;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputeStrokeBounds(float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        winrt::Windows::Foundation::Rect bounds{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputeStrokeBoundsWithStrokeStyle(strokeWidth, *(void**)(&strokeStyle), put_abi(bounds)));
        return bounds;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::ComputeStrokeBounds(float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle, winrt::Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
    {
        winrt::Windows::Foundation::Rect bounds{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->ComputeStrokeBoundsWithAllOptions(strokeWidth, *(void**)(&strokeStyle), impl::bind_in(transform), flatteningTolerance, put_abi(bounds)));
        return bounds;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::StrokeContainsPoint(winrt::Windows::Foundation::Numerics::float2 const& point, float strokeWidth) const
    {
        bool containsPoint{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->StrokeContainsPoint(impl::bind_in(point), strokeWidth, &containsPoint));
        return containsPoint;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::StrokeContainsPoint(winrt::Windows::Foundation::Numerics::float2 const& point, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        bool containsPoint{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->StrokeContainsPointWithStrokeStyle(impl::bind_in(point), strokeWidth, *(void**)(&strokeStyle), &containsPoint));
        return containsPoint;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::StrokeContainsPoint(winrt::Windows::Foundation::Numerics::float2 const& point, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle, winrt::Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
    {
        bool containsPoint{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->StrokeContainsPointWithAllOptions(impl::bind_in(point), strokeWidth, *(void**)(&strokeStyle), impl::bind_in(transform), flatteningTolerance, &containsPoint));
        return containsPoint;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Tessellate() const
    {
        uint32_t triangles_impl_size{};
        struct struct_Microsoft_Graphics_Canvas_Geometry_CanvasTriangleVertices* triangles{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->Tessellate(&triangles_impl_size, &triangles));
        return com_array<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasTriangleVertices>{ triangles, triangles_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Tessellate(winrt::Windows::Foundation::Numerics::float3x2 const& transform, float flatteningTolerance) const
    {
        uint32_t triangles_impl_size{};
        struct struct_Microsoft_Graphics_Canvas_Geometry_CanvasTriangleVertices* triangles{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->TessellateWithTransformAndFlatteningTolerance(impl::bind_in(transform), flatteningTolerance, &triangles_impl_size, &triangles));
        return com_array<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasTriangleVertices>{ triangles, triangles_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::SendPathTo(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver const& streamReader) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->SendPathTo(*(void**)(&streamReader)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometry<D>::Device() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry)->get_Device(&value));
        return winrt::Microsoft::Graphics::Canvas::CanvasDevice{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateRectangle(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Rect const& rect) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateRectangle(*(void**)(&resourceCreator), impl::bind_in(rect), &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateRectangle(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float x, float y, float w, float h) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateRectangleAtCoords(*(void**)(&resourceCreator), x, y, w, h, &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateRoundedRectangle(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Rect const& rect, float radiusX, float radiusY) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateRoundedRectangle(*(void**)(&resourceCreator), impl::bind_in(rect), radiusX, radiusY, &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateRoundedRectangle(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float x, float y, float w, float h, float radiusX, float radiusY) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateRoundedRectangleAtCoords(*(void**)(&resourceCreator), x, y, w, h, radiusX, radiusY, &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateEllipse(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radiusX, float radiusY) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateEllipse(*(void**)(&resourceCreator), impl::bind_in(centerPoint), radiusX, radiusY, &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateEllipse(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float x, float y, float radiusX, float radiusY) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateEllipseAtCoords(*(void**)(&resourceCreator), x, y, radiusX, radiusY, &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateCircle(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radius) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateCircle(*(void**)(&resourceCreator), impl::bind_in(centerPoint), radius, &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateCircle(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float x, float y, float radius) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateCircleAtCoords(*(void**)(&resourceCreator), x, y, radius, &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreatePath(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasPathBuilder const& pathBuilder) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreatePath(*(void**)(&pathBuilder), &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreatePolygon(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Windows::Foundation::Numerics::float2 const> points) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreatePolygon(*(void**)(&resourceCreator), points.size(), get_abi(points), &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateGroup(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const> geometries) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateGroup(*(void**)(&resourceCreator), geometries.size(), get_abi(geometries), &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateGroup(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const> geometries, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination const& filledRegionDetermination) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateGroupWithFilledRegionDetermination(*(void**)(&resourceCreator), geometries.size(), get_abi(geometries), static_cast<int32_t>(filledRegionDetermination), &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateText(winrt::Microsoft::Graphics::Canvas::Text::CanvasTextLayout const& textLayout) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateText(*(void**)(&textLayout), &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::CreateGlyphRun(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Numerics::float2 const& point, winrt::Microsoft::Graphics::Canvas::Text::CanvasFontFace const& fontFace, float fontSize, array_view<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyph const> glyphs, bool isSideways, uint32_t bidiLevel, winrt::Microsoft::Graphics::Canvas::Text::CanvasTextMeasuringMode const& measuringMode, winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyphOrientation const& glyphOrientation) const
    {
        void* geometry{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->CreateGlyphRun(*(void**)(&resourceCreator), impl::bind_in(point), *(void**)(&fontFace), fontSize, glyphs.size(), get_abi(glyphs), isSideways, bidiLevel, static_cast<int32_t>(measuringMode), static_cast<int32_t>(glyphOrientation), &geometry));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry{ geometry, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::ComputeFlatteningTolerance(float dpi, float maximumZoomFactor) const
    {
        float flatteningTolerance{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->ComputeFlatteningTolerance(dpi, maximumZoomFactor, &flatteningTolerance));
        return flatteningTolerance;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::ComputeFlatteningTolerance(float dpi, float maximumZoomFactor, winrt::Windows::Foundation::Numerics::float3x2 const& expectedGeometryTransform) const
    {
        float flatteningTolerance{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->ComputeFlatteningToleranceWithTransform(dpi, maximumZoomFactor, impl::bind_in(expectedGeometryTransform), &flatteningTolerance));
        return flatteningTolerance;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGeometryStatics<D>::DefaultFlatteningTolerance() const
    {
        float value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics)->get_DefaultFlatteningTolerance(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGradientMesh<D>::Patches() const
    {
        uint32_t valueElements_impl_size{};
        struct struct_Microsoft_Graphics_Canvas_Geometry_CanvasGradientMeshPatch* valueElements{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMesh)->get_Patches(&valueElements_impl_size, &valueElements));
        return com_array<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch>{ valueElements, valueElements_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGradientMesh<D>::GetBounds(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator) const
    {
        winrt::Windows::Foundation::Rect bounds{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMesh)->GetBounds(*(void**)(&resourceCreator), put_abi(bounds)));
        return bounds;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGradientMesh<D>::GetBounds(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Numerics::float3x2 const& transform) const
    {
        winrt::Windows::Foundation::Rect bounds{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMesh)->GetBoundsWithTransform(*(void**)(&resourceCreator), impl::bind_in(transform), put_abi(bounds)));
        return bounds;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGradientMesh<D>::Device() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMesh)->get_Device(&value));
        return winrt::Microsoft::Graphics::Canvas::CanvasDevice{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGradientMeshFactory<D>::Create(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch const> patchElements) const
    {
        void* canvasGradientMesh{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshFactory)->Create(*(void**)(&resourceCreator), patchElements.size(), get_abi(patchElements), &canvasGradientMesh));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMesh{ canvasGradientMesh, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGradientMeshStatics<D>::CreateCoonsPatch(array_view<winrt::Windows::Foundation::Numerics::float2 const> points, array_view<winrt::Windows::Foundation::Numerics::float4 const> colors, array_view<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const> edges) const
    {
        winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch gradientMeshPatch{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshStatics)->CreateCoonsPatch(points.size(), get_abi(points), colors.size(), get_abi(colors), edges.size(), get_abi(edges), put_abi(gradientMeshPatch)));
        return gradientMeshPatch;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasGradientMeshStatics<D>::CreateTensorPatch(array_view<winrt::Windows::Foundation::Numerics::float2 const> points, array_view<winrt::Windows::Foundation::Numerics::float4 const> colors, array_view<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const> edges) const
    {
        winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch gradientMeshPatch{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshStatics)->CreateTensorPatch(points.size(), get_abi(points), colors.size(), get_abi(colors), edges.size(), get_abi(edges), put_abi(gradientMeshPatch)));
        return gradientMeshPatch;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::BeginFigure(winrt::Windows::Foundation::Numerics::float2 const& startPoint, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill const& figureFill) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->BeginFigureWithFigureFill(impl::bind_in(startPoint), static_cast<int32_t>(figureFill)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::BeginFigure(winrt::Windows::Foundation::Numerics::float2 const& startPoint) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->BeginFigure(impl::bind_in(startPoint)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::BeginFigure(float startX, float startY, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill const& figureFill) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->BeginFigureAtCoordsWithFigureFill(startX, startY, static_cast<int32_t>(figureFill)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::BeginFigure(float startX, float startY) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->BeginFigureAtCoords(startX, startY));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::AddArc(winrt::Windows::Foundation::Numerics::float2 const& endPoint, float radiusX, float radiusY, float rotationAngle, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasSweepDirection const& sweepDirection, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasArcSize const& arcSize) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->AddArcToPoint(impl::bind_in(endPoint), radiusX, radiusY, rotationAngle, static_cast<int32_t>(sweepDirection), static_cast<int32_t>(arcSize)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::AddArc(winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radiusX, float radiusY, float startAngle, float sweepAngle) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->AddArcAroundEllipse(impl::bind_in(centerPoint), radiusX, radiusY, startAngle, sweepAngle));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::AddCubicBezier(winrt::Windows::Foundation::Numerics::float2 const& controlPoint1, winrt::Windows::Foundation::Numerics::float2 const& controlPoint2, winrt::Windows::Foundation::Numerics::float2 const& endPoint) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->AddCubicBezier(impl::bind_in(controlPoint1), impl::bind_in(controlPoint2), impl::bind_in(endPoint)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::AddLine(winrt::Windows::Foundation::Numerics::float2 const& endPoint) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->AddLine(impl::bind_in(endPoint)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::AddLine(float x, float y) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->AddLineWithCoords(x, y));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::AddQuadraticBezier(winrt::Windows::Foundation::Numerics::float2 const& controlPoint, winrt::Windows::Foundation::Numerics::float2 const& endPoint) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->AddQuadraticBezier(impl::bind_in(controlPoint), impl::bind_in(endPoint)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::SetFilledRegionDetermination(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination const& filledRegionDetermination) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->SetFilledRegionDetermination(static_cast<int32_t>(filledRegionDetermination)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::SetSegmentOptions(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFigureSegmentOptions const& figureSegmentOptions) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->SetSegmentOptions(static_cast<uint32_t>(figureSegmentOptions)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::EndFigure(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFigureLoop const& figureLoop) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->EndFigure(static_cast<int32_t>(figureLoop)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilder<D>::AddGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder)->AddGeometry(*(void**)(&geometry)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathBuilderFactory<D>::Create(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator) const
    {
        void* canvasPathBuilder{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilderFactory)->Create(*(void**)(&resourceCreator), &canvasPathBuilder));
        return winrt::Microsoft::Graphics::Canvas::Geometry::CanvasPathBuilder{ canvasPathBuilder, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathReceiver<D>::BeginFigure(winrt::Windows::Foundation::Numerics::float2 const& startPoint, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill const& figureFill) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver)->BeginFigure(impl::bind_in(startPoint), static_cast<int32_t>(figureFill)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathReceiver<D>::AddArc(winrt::Windows::Foundation::Numerics::float2 const& endPoint, float radiusX, float radiusY, float rotationAngle, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasSweepDirection const& sweepDirection, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasArcSize const& arcSize) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver)->AddArc(impl::bind_in(endPoint), radiusX, radiusY, rotationAngle, static_cast<int32_t>(sweepDirection), static_cast<int32_t>(arcSize)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathReceiver<D>::AddCubicBezier(winrt::Windows::Foundation::Numerics::float2 const& controlPoint1, winrt::Windows::Foundation::Numerics::float2 const& controlPoint2, winrt::Windows::Foundation::Numerics::float2 const& endPoint) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver)->AddCubicBezier(impl::bind_in(controlPoint1), impl::bind_in(controlPoint2), impl::bind_in(endPoint)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathReceiver<D>::AddLine(winrt::Windows::Foundation::Numerics::float2 const& endPoint) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver)->AddLine(impl::bind_in(endPoint)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathReceiver<D>::AddQuadraticBezier(winrt::Windows::Foundation::Numerics::float2 const& controlPoint, winrt::Windows::Foundation::Numerics::float2 const& endPoint) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver)->AddQuadraticBezier(impl::bind_in(controlPoint), impl::bind_in(endPoint)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathReceiver<D>::SetFilledRegionDetermination(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination const& filledRegionDetermination) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver)->SetFilledRegionDetermination(static_cast<int32_t>(filledRegionDetermination)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathReceiver<D>::SetSegmentOptions(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFigureSegmentOptions const& figureSegmentOptions) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver)->SetSegmentOptions(static_cast<uint32_t>(figureSegmentOptions)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasPathReceiver<D>::EndFigure(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFigureLoop const& figureLoop) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver)->EndFigure(static_cast<int32_t>(figureLoop)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::StartCap() const
    {
        winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_StartCap(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::StartCap(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_StartCap(static_cast<int32_t>(value)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::EndCap() const
    {
        winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_EndCap(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::EndCap(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_EndCap(static_cast<int32_t>(value)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::DashCap() const
    {
        winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_DashCap(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::DashCap(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_DashCap(static_cast<int32_t>(value)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::LineJoin() const
    {
        winrt::Microsoft::Graphics::Canvas::Geometry::CanvasLineJoin value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_LineJoin(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::LineJoin(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasLineJoin const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_LineJoin(static_cast<int32_t>(value)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::MiterLimit() const
    {
        float value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_MiterLimit(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::MiterLimit(float value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_MiterLimit(value));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::DashStyle() const
    {
        winrt::Microsoft::Graphics::Canvas::Geometry::CanvasDashStyle value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_DashStyle(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::DashStyle(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasDashStyle const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_DashStyle(static_cast<int32_t>(value)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::DashOffset() const
    {
        float value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_DashOffset(&value));
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::DashOffset(float value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_DashOffset(value));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::CustomDashStyle() const
    {
        uint32_t valueElements_impl_size{};
        float* valueElements{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_CustomDashStyle(&valueElements_impl_size, &valueElements));
        return com_array<float>{ valueElements, valueElements_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::CustomDashStyle(array_view<float const> valueElements) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_CustomDashStyle(valueElements.size(), get_abi(valueElements)));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::TransformBehavior() const
    {
        winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeTransformBehavior value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->get_TransformBehavior(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Geometry_ICanvasStrokeStyle<D>::TransformBehavior(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeTransformBehavior const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle)->put_TransformBehavior(static_cast<int32_t>(value)));
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometry> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometry>
    {
        int32_t __stdcall get_Device(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDevice>(this->shim().Device());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics>
    {
        int32_t __stdcall CreateFill(void* geometry, void** cachedGeometry) noexcept final try
        {
            clear_abi(cachedGeometry);
            typename D::abi_guard guard(this->shim());
            *cachedGeometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry>(this->shim().CreateFill(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFillWithFlatteningTolerance(void* geometry, float flatteningTolerance, void** cachedGeometry) noexcept final try
        {
            clear_abi(cachedGeometry);
            typename D::abi_guard guard(this->shim());
            *cachedGeometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry>(this->shim().CreateFill(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateStroke(void* geometry, float strokeWidth, void** cachedGeometry) noexcept final try
        {
            clear_abi(cachedGeometry);
            typename D::abi_guard guard(this->shim());
            *cachedGeometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry>(this->shim().CreateStroke(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), strokeWidth));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateStrokeWithStrokeStyle(void* geometry, float strokeWidth, void* strokeStyle, void** cachedGeometry) noexcept final try
        {
            clear_abi(cachedGeometry);
            typename D::abi_guard guard(this->shim());
            *cachedGeometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry>(this->shim().CreateStroke(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateStrokeWithStrokeStyleAndFlatteningTolerance(void* geometry, float strokeWidth, void* strokeStyle, float flatteningTolerance, void** cachedGeometry) noexcept final try
        {
            clear_abi(cachedGeometry);
            typename D::abi_guard guard(this->shim());
            *cachedGeometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry>(this->shim().CreateStroke(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry>
    {
        int32_t __stdcall CombineWith(void* otherGeometry, winrt::Windows::Foundation::Numerics::float3x2 otherGeometryTransform, int32_t combine, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CombineWith(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&otherGeometry), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&otherGeometryTransform), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometryCombine const*>(&combine)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CombineWithUsingFlatteningTolerance(void* otherGeometry, winrt::Windows::Foundation::Numerics::float3x2 otherGeometryTransform, int32_t combine, float flatteningTolerance, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CombineWith(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&otherGeometry), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&otherGeometryTransform), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometryCombine const*>(&combine), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Stroke(float strokeWidth, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().Stroke(strokeWidth));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall StrokeWithStrokeStyle(float strokeWidth, void* strokeStyle, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().Stroke(strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall StrokeWithAllOptions(float strokeWidth, void* strokeStyle, winrt::Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().Stroke(strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Outline(void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().Outline());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall OutlineWithTransformAndFlatteningTolerance(winrt::Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().Outline(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Simplify(int32_t simplification, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().Simplify(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometrySimplification const*>(&simplification)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SimplifyWithTransformAndFlatteningTolerance(int32_t simplification, winrt::Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().Simplify(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometrySimplification const*>(&simplification), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Transform(winrt::Windows::Foundation::Numerics::float3x2 transform, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().Transform(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CompareWith(void* otherGeometry, int32_t* relation) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *relation = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometryRelation>(this->shim().CompareWith(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&otherGeometry)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CompareWithUsingTransformAndFlatteningTolerance(void* otherGeometry, winrt::Windows::Foundation::Numerics::float3x2 otherGeometryTransform, float flatteningTolerance, int32_t* relation) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *relation = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometryRelation>(this->shim().CompareWith(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&otherGeometry), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&otherGeometryTransform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ComputeArea(float* area) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *area = detach_from<float>(this->shim().ComputeArea());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ComputeAreaWithTransformAndFlatteningTolerance(winrt::Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, float* area) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *area = detach_from<float>(this->shim().ComputeArea(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ComputePathLength(float* length) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *length = detach_from<float>(this->shim().ComputePathLength());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ComputePathLengthWithTransformAndFlatteningTolerance(winrt::Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, float* length) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *length = detach_from<float>(this->shim().ComputePathLength(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ComputePointOnPath(float distance, winrt::Windows::Foundation::Numerics::float2* point) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Numerics::float2>(point);
            typename D::abi_guard guard(this->shim());
            *point = detach_from<winrt::Windows::Foundation::Numerics::float2>(this->shim().ComputePointOnPath(distance));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ComputePointOnPathWithTangent(float distance, winrt::Windows::Foundation::Numerics::float2* tangent, winrt::Windows::Foundation::Numerics::float2* point) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Numerics::float2>(tangent);
            zero_abi<winrt::Windows::Foundation::Numerics::float2>(point);
            typename D::abi_guard guard(this->shim());
            *point = detach_from<winrt::Windows::Foundation::Numerics::float2>(this->shim().ComputePointOnPath(distance, *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2*>(tangent)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ComputePointOnPathWithTransformAndFlatteningToleranceAndTangent(float length, winrt::Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, winrt::Windows::Foundation::Numerics::float2* tangent, winrt::Windows::Foundation::Numerics::float2* point) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Numerics::float2>(tangent);
            zero_abi<winrt::Windows::Foundation::Numerics::float2>(point);
            typename D::abi_guard guard(this->shim());
            *point = detach_from<winrt::Windows::Foundation::Numerics::float2>(this->shim().ComputePointOnPath(length, *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance, *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2*>(tangent)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillContainsPoint(winrt::Windows::Foundation::Numerics::float2 point, bool* containsPoint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *containsPoint = detach_from<bool>(this->shim().FillContainsPoint(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillContainsPointWithTransformAndFlatteningTolerance(winrt::Windows::Foundation::Numerics::float2 point, winrt::Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, bool* containsPoint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *containsPoint = detach_from<bool>(this->shim().FillContainsPoint(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ComputeBounds(winrt::Windows::Foundation::Rect* bounds) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Rect>(bounds);
            typename D::abi_guard guard(this->shim());
            *bounds = detach_from<winrt::Windows::Foundation::Rect>(this->shim().ComputeBounds());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ComputeBoundsWithTransform(winrt::Windows::Foundation::Numerics::float3x2 transform, winrt::Windows::Foundation::Rect* bounds) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Rect>(bounds);
            typename D::abi_guard guard(this->shim());
            *bounds = detach_from<winrt::Windows::Foundation::Rect>(this->shim().ComputeBounds(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ComputeStrokeBounds(float strokeWidth, winrt::Windows::Foundation::Rect* bounds) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Rect>(bounds);
            typename D::abi_guard guard(this->shim());
            *bounds = detach_from<winrt::Windows::Foundation::Rect>(this->shim().ComputeStrokeBounds(strokeWidth));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ComputeStrokeBoundsWithStrokeStyle(float strokeWidth, void* strokeStyle, winrt::Windows::Foundation::Rect* bounds) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Rect>(bounds);
            typename D::abi_guard guard(this->shim());
            *bounds = detach_from<winrt::Windows::Foundation::Rect>(this->shim().ComputeStrokeBounds(strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ComputeStrokeBoundsWithAllOptions(float strokeWidth, void* strokeStyle, winrt::Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, winrt::Windows::Foundation::Rect* bounds) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Rect>(bounds);
            typename D::abi_guard guard(this->shim());
            *bounds = detach_from<winrt::Windows::Foundation::Rect>(this->shim().ComputeStrokeBounds(strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall StrokeContainsPoint(winrt::Windows::Foundation::Numerics::float2 point, float strokeWidth, bool* containsPoint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *containsPoint = detach_from<bool>(this->shim().StrokeContainsPoint(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point), strokeWidth));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall StrokeContainsPointWithStrokeStyle(winrt::Windows::Foundation::Numerics::float2 point, float strokeWidth, void* strokeStyle, bool* containsPoint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *containsPoint = detach_from<bool>(this->shim().StrokeContainsPoint(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall StrokeContainsPointWithAllOptions(winrt::Windows::Foundation::Numerics::float2 point, float strokeWidth, void* strokeStyle, winrt::Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, bool* containsPoint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *containsPoint = detach_from<bool>(this->shim().StrokeContainsPoint(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Tessellate(uint32_t* __trianglesSize, struct struct_Microsoft_Graphics_Canvas_Geometry_CanvasTriangleVertices** triangles) noexcept final try
        {
            clear_abi(triangles);
            typename D::abi_guard guard(this->shim());
            std::tie(*__trianglesSize, *triangles) = detach_abi(this->shim().Tessellate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TessellateWithTransformAndFlatteningTolerance(winrt::Windows::Foundation::Numerics::float3x2 transform, float flatteningTolerance, uint32_t* __trianglesSize, struct struct_Microsoft_Graphics_Canvas_Geometry_CanvasTriangleVertices** triangles) noexcept final try
        {
            clear_abi(triangles);
            typename D::abi_guard guard(this->shim());
            std::tie(*__trianglesSize, *triangles) = detach_abi(this->shim().Tessellate(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform), flatteningTolerance));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SendPathTo(void* streamReader) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SendPathTo(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver const*>(&streamReader));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Device(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDevice>(this->shim().Device());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics>
    {
        int32_t __stdcall CreateRectangle(void* resourceCreator, winrt::Windows::Foundation::Rect rect, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateRectangle(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateRectangleAtCoords(void* resourceCreator, float x, float y, float w, float h, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateRectangle(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), x, y, w, h));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateRoundedRectangle(void* resourceCreator, winrt::Windows::Foundation::Rect rect, float radiusX, float radiusY, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateRoundedRectangle(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), radiusX, radiusY));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateRoundedRectangleAtCoords(void* resourceCreator, float x, float y, float w, float h, float radiusX, float radiusY, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateRoundedRectangle(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), x, y, w, h, radiusX, radiusY));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateEllipse(void* resourceCreator, winrt::Windows::Foundation::Numerics::float2 centerPoint, float radiusX, float radiusY, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateEllipse(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radiusX, radiusY));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateEllipseAtCoords(void* resourceCreator, float x, float y, float radiusX, float radiusY, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateEllipse(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), x, y, radiusX, radiusY));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateCircle(void* resourceCreator, winrt::Windows::Foundation::Numerics::float2 centerPoint, float radius, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateCircle(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radius));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateCircleAtCoords(void* resourceCreator, float x, float y, float radius, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateCircle(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), x, y, radius));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreatePath(void* pathBuilder, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreatePath(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasPathBuilder const*>(&pathBuilder)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreatePolygon(void* resourceCreator, uint32_t __pointsSize, winrt::Windows::Foundation::Numerics::float2* points, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreatePolygon(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Windows::Foundation::Numerics::float2 const>(reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const *>(points), reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const *>(points) + __pointsSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateGroup(void* resourceCreator, uint32_t __geometriesSize, void** geometries, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateGroup(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const *>(geometries), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const *>(geometries) + __geometriesSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateGroupWithFilledRegionDetermination(void* resourceCreator, uint32_t __geometriesSize, void** geometries, int32_t filledRegionDetermination, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateGroup(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const *>(geometries), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const *>(geometries) + __geometriesSize), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination const*>(&filledRegionDetermination)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateText(void* textLayout, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateText(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextLayout const*>(&textLayout)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateGlyphRun(void* resourceCreator, winrt::Windows::Foundation::Numerics::float2 point, void* fontFace, float fontSize, uint32_t __glyphsSize, struct struct_Microsoft_Graphics_Canvas_Text_CanvasGlyph* glyphs, bool isSideways, uint32_t bidiLevel, int32_t measuringMode, int32_t glyphOrientation, void** geometry) noexcept final try
        {
            clear_abi(geometry);
            typename D::abi_guard guard(this->shim());
            *geometry = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry>(this->shim().CreateGlyphRun(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasFontFace const*>(&fontFace), fontSize, array_view<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyph const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyph const *>(glyphs), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyph const *>(glyphs) + __glyphsSize), isSideways, bidiLevel, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextMeasuringMode const*>(&measuringMode), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyphOrientation const*>(&glyphOrientation)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ComputeFlatteningTolerance(float dpi, float maximumZoomFactor, float* flatteningTolerance) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *flatteningTolerance = detach_from<float>(this->shim().ComputeFlatteningTolerance(dpi, maximumZoomFactor));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ComputeFlatteningToleranceWithTransform(float dpi, float maximumZoomFactor, winrt::Windows::Foundation::Numerics::float3x2 expectedGeometryTransform, float* flatteningTolerance) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *flatteningTolerance = detach_from<float>(this->shim().ComputeFlatteningTolerance(dpi, maximumZoomFactor, *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&expectedGeometryTransform)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DefaultFlatteningTolerance(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().DefaultFlatteningTolerance());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMesh> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMesh>
    {
        int32_t __stdcall get_Patches(uint32_t* __valueElementsSize, struct struct_Microsoft_Graphics_Canvas_Geometry_CanvasGradientMeshPatch** valueElements) noexcept final try
        {
            clear_abi(valueElements);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueElementsSize, *valueElements) = detach_abi(this->shim().Patches());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetBounds(void* resourceCreator, winrt::Windows::Foundation::Rect* bounds) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Rect>(bounds);
            typename D::abi_guard guard(this->shim());
            *bounds = detach_from<winrt::Windows::Foundation::Rect>(this->shim().GetBounds(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetBoundsWithTransform(void* resourceCreator, winrt::Windows::Foundation::Numerics::float3x2 transform, winrt::Windows::Foundation::Rect* bounds) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Rect>(bounds);
            typename D::abi_guard guard(this->shim());
            *bounds = detach_from<winrt::Windows::Foundation::Rect>(this->shim().GetBounds(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Device(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDevice>(this->shim().Device());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshFactory> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshFactory>
    {
        int32_t __stdcall Create(void* resourceCreator, uint32_t __patchElementsSize, struct struct_Microsoft_Graphics_Canvas_Geometry_CanvasGradientMeshPatch* patchElements, void** canvasGradientMesh) noexcept final try
        {
            clear_abi(canvasGradientMesh);
            typename D::abi_guard guard(this->shim());
            *canvasGradientMesh = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMesh>(this->shim().Create(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch const *>(patchElements), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch const *>(patchElements) + __patchElementsSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshStatics> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshStatics>
    {
        int32_t __stdcall CreateCoonsPatch(uint32_t __pointsSize, winrt::Windows::Foundation::Numerics::float2* points, uint32_t __colorsSize, winrt::Windows::Foundation::Numerics::float4* colors, uint32_t __edgesSize, int32_t* edges, struct struct_Microsoft_Graphics_Canvas_Geometry_CanvasGradientMeshPatch* gradientMeshPatch) noexcept final try
        {
            zero_abi<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch>(gradientMeshPatch);
            typename D::abi_guard guard(this->shim());
            *gradientMeshPatch = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch>(this->shim().CreateCoonsPatch(array_view<winrt::Windows::Foundation::Numerics::float2 const>(reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const *>(points), reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const *>(points) + __pointsSize), array_view<winrt::Windows::Foundation::Numerics::float4 const>(reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const *>(colors), reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const *>(colors) + __colorsSize), array_view<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const *>(edges), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const *>(edges) + __edgesSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateTensorPatch(uint32_t __pointsSize, winrt::Windows::Foundation::Numerics::float2* points, uint32_t __colorsSize, winrt::Windows::Foundation::Numerics::float4* colors, uint32_t __edgesSize, int32_t* edges, struct struct_Microsoft_Graphics_Canvas_Geometry_CanvasGradientMeshPatch* gradientMeshPatch) noexcept final try
        {
            zero_abi<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch>(gradientMeshPatch);
            typename D::abi_guard guard(this->shim());
            *gradientMeshPatch = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch>(this->shim().CreateTensorPatch(array_view<winrt::Windows::Foundation::Numerics::float2 const>(reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const *>(points), reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const *>(points) + __pointsSize), array_view<winrt::Windows::Foundation::Numerics::float4 const>(reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const *>(colors), reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const *>(colors) + __colorsSize), array_view<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const *>(edges), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const *>(edges) + __edgesSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder>
    {
        int32_t __stdcall BeginFigureWithFigureFill(winrt::Windows::Foundation::Numerics::float2 startPoint, int32_t figureFill) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().BeginFigure(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&startPoint), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill const*>(&figureFill));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall BeginFigure(winrt::Windows::Foundation::Numerics::float2 startPoint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().BeginFigure(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&startPoint));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall BeginFigureAtCoordsWithFigureFill(float startX, float startY, int32_t figureFill) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().BeginFigure(startX, startY, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill const*>(&figureFill));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall BeginFigureAtCoords(float startX, float startY) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().BeginFigure(startX, startY);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddArcToPoint(winrt::Windows::Foundation::Numerics::float2 endPoint, float radiusX, float radiusY, float rotationAngle, int32_t sweepDirection, int32_t arcSize) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AddArc(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&endPoint), radiusX, radiusY, rotationAngle, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasSweepDirection const*>(&sweepDirection), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasArcSize const*>(&arcSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddArcAroundEllipse(winrt::Windows::Foundation::Numerics::float2 centerPoint, float radiusX, float radiusY, float startAngle, float sweepAngle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AddArc(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radiusX, radiusY, startAngle, sweepAngle);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddCubicBezier(winrt::Windows::Foundation::Numerics::float2 controlPoint1, winrt::Windows::Foundation::Numerics::float2 controlPoint2, winrt::Windows::Foundation::Numerics::float2 endPoint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AddCubicBezier(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&controlPoint1), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&controlPoint2), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&endPoint));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddLine(winrt::Windows::Foundation::Numerics::float2 endPoint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AddLine(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&endPoint));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddLineWithCoords(float x, float y) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AddLine(x, y);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddQuadraticBezier(winrt::Windows::Foundation::Numerics::float2 controlPoint, winrt::Windows::Foundation::Numerics::float2 endPoint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AddQuadraticBezier(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&controlPoint), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&endPoint));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetFilledRegionDetermination(int32_t filledRegionDetermination) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetFilledRegionDetermination(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination const*>(&filledRegionDetermination));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetSegmentOptions(uint32_t figureSegmentOptions) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetSegmentOptions(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFigureSegmentOptions const*>(&figureSegmentOptions));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EndFigure(int32_t figureLoop) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().EndFigure(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFigureLoop const*>(&figureLoop));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddGeometry(void* geometry) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AddGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilderFactory> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilderFactory>
    {
        int32_t __stdcall Create(void* resourceCreator, void** canvasPathBuilder) noexcept final try
        {
            clear_abi(canvasPathBuilder);
            typename D::abi_guard guard(this->shim());
            *canvasPathBuilder = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasPathBuilder>(this->shim().Create(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver>
    {
        int32_t __stdcall BeginFigure(winrt::Windows::Foundation::Numerics::float2 startPoint, int32_t figureFill) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().BeginFigure(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&startPoint), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFigureFill const*>(&figureFill));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddArc(winrt::Windows::Foundation::Numerics::float2 endPoint, float radiusX, float radiusY, float rotationAngle, int32_t sweepDirection, int32_t arcSize) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AddArc(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&endPoint), radiusX, radiusY, rotationAngle, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasSweepDirection const*>(&sweepDirection), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasArcSize const*>(&arcSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddCubicBezier(winrt::Windows::Foundation::Numerics::float2 controlPoint1, winrt::Windows::Foundation::Numerics::float2 controlPoint2, winrt::Windows::Foundation::Numerics::float2 endPoint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AddCubicBezier(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&controlPoint1), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&controlPoint2), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&endPoint));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddLine(winrt::Windows::Foundation::Numerics::float2 endPoint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AddLine(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&endPoint));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall AddQuadraticBezier(winrt::Windows::Foundation::Numerics::float2 controlPoint, winrt::Windows::Foundation::Numerics::float2 endPoint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AddQuadraticBezier(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&controlPoint), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&endPoint));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetFilledRegionDetermination(int32_t filledRegionDetermination) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetFilledRegionDetermination(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination const*>(&filledRegionDetermination));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetSegmentOptions(uint32_t figureSegmentOptions) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetSegmentOptions(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFigureSegmentOptions const*>(&figureSegmentOptions));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall EndFigure(int32_t figureLoop) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().EndFigure(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFigureLoop const*>(&figureLoop));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle>
    {
        int32_t __stdcall get_StartCap(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle>(this->shim().StartCap());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_StartCap(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StartCap(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_EndCap(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle>(this->shim().EndCap());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_EndCap(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().EndCap(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DashCap(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle>(this->shim().DashCap());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DashCap(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DashCap(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCapStyle const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LineJoin(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasLineJoin>(this->shim().LineJoin());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LineJoin(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LineJoin(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasLineJoin const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MiterLimit(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().MiterLimit());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MiterLimit(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MiterLimit(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DashStyle(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasDashStyle>(this->shim().DashStyle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DashStyle(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DashStyle(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasDashStyle const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DashOffset(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().DashOffset());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DashOffset(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DashOffset(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CustomDashStyle(uint32_t* __valueElementsSize, float** valueElements) noexcept final try
        {
            clear_abi(valueElements);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueElementsSize, *valueElements) = detach_abi(this->shim().CustomDashStyle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_CustomDashStyle(uint32_t __valueElementsSize, float* valueElements) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CustomDashStyle(array_view<float const>(reinterpret_cast<float const *>(valueElements), reinterpret_cast<float const *>(valueElements) + __valueElementsSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TransformBehavior(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeTransformBehavior>(this->shim().TransformBehavior());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TransformBehavior(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TransformBehavior(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeTransformBehavior const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Graphics::Canvas::Geometry
{
    constexpr auto operator|(CanvasFigureSegmentOptions const left, CanvasFigureSegmentOptions const right) noexcept
    {
        return static_cast<CanvasFigureSegmentOptions>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(CanvasFigureSegmentOptions& left, CanvasFigureSegmentOptions const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(CanvasFigureSegmentOptions const left, CanvasFigureSegmentOptions const right) noexcept
    {
        return static_cast<CanvasFigureSegmentOptions>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(CanvasFigureSegmentOptions& left, CanvasFigureSegmentOptions const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(CanvasFigureSegmentOptions const value) noexcept
    {
        return static_cast<CanvasFigureSegmentOptions>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(CanvasFigureSegmentOptions const left, CanvasFigureSegmentOptions const right) noexcept
    {
        return static_cast<CanvasFigureSegmentOptions>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(CanvasFigureSegmentOptions& left, CanvasFigureSegmentOptions const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    inline auto CanvasCachedGeometry::CreateFill(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry)
    {
        return impl::call_factory<CanvasCachedGeometry, ICanvasCachedGeometryStatics>([&](ICanvasCachedGeometryStatics const& f) { return f.CreateFill(geometry); });
    }
    inline auto CanvasCachedGeometry::CreateFill(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float flatteningTolerance)
    {
        return impl::call_factory<CanvasCachedGeometry, ICanvasCachedGeometryStatics>([&](ICanvasCachedGeometryStatics const& f) { return f.CreateFill(geometry, flatteningTolerance); });
    }
    inline auto CanvasCachedGeometry::CreateStroke(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float strokeWidth)
    {
        return impl::call_factory<CanvasCachedGeometry, ICanvasCachedGeometryStatics>([&](ICanvasCachedGeometryStatics const& f) { return f.CreateStroke(geometry, strokeWidth); });
    }
    inline auto CanvasCachedGeometry::CreateStroke(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle)
    {
        return impl::call_factory<CanvasCachedGeometry, ICanvasCachedGeometryStatics>([&](ICanvasCachedGeometryStatics const& f) { return f.CreateStroke(geometry, strokeWidth, strokeStyle); });
    }
    inline auto CanvasCachedGeometry::CreateStroke(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle, float flatteningTolerance)
    {
        return impl::call_factory<CanvasCachedGeometry, ICanvasCachedGeometryStatics>([&](ICanvasCachedGeometryStatics const& f) { return f.CreateStroke(geometry, strokeWidth, strokeStyle, flatteningTolerance); });
    }
    inline auto CanvasGeometry::CreateRectangle(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Rect const& rect)
    {
        return impl::call_factory<CanvasGeometry, ICanvasGeometryStatics>([&](ICanvasGeometryStatics const& f) { return f.CreateRectangle(resourceCreator, rect); });
    }
    inline auto CanvasGeometry::CreateRectangle(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float x, float y, float w, float h)
    {
        return impl::call_factory<CanvasGeometry, ICanvasGeometryStatics>([&](ICanvasGeometryStatics const& f) { return f.CreateRectangle(resourceCreator, x, y, w, h); });
    }
    inline auto CanvasGeometry::CreateRoundedRectangle(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Rect const& rect, float radiusX, float radiusY)
    {
        return impl::call_factory<CanvasGeometry, ICanvasGeometryStatics>([&](ICanvasGeometryStatics const& f) { return f.CreateRoundedRectangle(resourceCreator, rect, radiusX, radiusY); });
    }
    inline auto CanvasGeometry::CreateRoundedRectangle(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float x, float y, float w, float h, float radiusX, float radiusY)
    {
        return impl::call_factory<CanvasGeometry, ICanvasGeometryStatics>([&](ICanvasGeometryStatics const& f) { return f.CreateRoundedRectangle(resourceCreator, x, y, w, h, radiusX, radiusY); });
    }
    inline auto CanvasGeometry::CreateEllipse(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radiusX, float radiusY)
    {
        return impl::call_factory<CanvasGeometry, ICanvasGeometryStatics>([&](ICanvasGeometryStatics const& f) { return f.CreateEllipse(resourceCreator, centerPoint, radiusX, radiusY); });
    }
    inline auto CanvasGeometry::CreateEllipse(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float x, float y, float radiusX, float radiusY)
    {
        return impl::call_factory<CanvasGeometry, ICanvasGeometryStatics>([&](ICanvasGeometryStatics const& f) { return f.CreateEllipse(resourceCreator, x, y, radiusX, radiusY); });
    }
    inline auto CanvasGeometry::CreateCircle(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radius)
    {
        return impl::call_factory<CanvasGeometry, ICanvasGeometryStatics>([&](ICanvasGeometryStatics const& f) { return f.CreateCircle(resourceCreator, centerPoint, radius); });
    }
    inline auto CanvasGeometry::CreateCircle(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float x, float y, float radius)
    {
        return impl::call_factory<CanvasGeometry, ICanvasGeometryStatics>([&](ICanvasGeometryStatics const& f) { return f.CreateCircle(resourceCreator, x, y, radius); });
    }
    inline auto CanvasGeometry::CreatePath(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasPathBuilder const& pathBuilder)
    {
        return impl::call_factory<CanvasGeometry, ICanvasGeometryStatics>([&](ICanvasGeometryStatics const& f) { return f.CreatePath(pathBuilder); });
    }
    inline auto CanvasGeometry::CreatePolygon(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Windows::Foundation::Numerics::float2 const> points)
    {
        return impl::call_factory<CanvasGeometry, ICanvasGeometryStatics>([&](ICanvasGeometryStatics const& f) { return f.CreatePolygon(resourceCreator, points); });
    }
    inline auto CanvasGeometry::CreateGroup(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const> geometries)
    {
        return impl::call_factory<CanvasGeometry, ICanvasGeometryStatics>([&](ICanvasGeometryStatics const& f) { return f.CreateGroup(resourceCreator, geometries); });
    }
    inline auto CanvasGeometry::CreateGroup(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const> geometries, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasFilledRegionDetermination const& filledRegionDetermination)
    {
        return impl::call_factory<CanvasGeometry, ICanvasGeometryStatics>([&](ICanvasGeometryStatics const& f) { return f.CreateGroup(resourceCreator, geometries, filledRegionDetermination); });
    }
    inline auto CanvasGeometry::CreateText(winrt::Microsoft::Graphics::Canvas::Text::CanvasTextLayout const& textLayout)
    {
        return impl::call_factory<CanvasGeometry, ICanvasGeometryStatics>([&](ICanvasGeometryStatics const& f) { return f.CreateText(textLayout); });
    }
    inline auto CanvasGeometry::CreateGlyphRun(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Numerics::float2 const& point, winrt::Microsoft::Graphics::Canvas::Text::CanvasFontFace const& fontFace, float fontSize, array_view<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyph const> glyphs, bool isSideways, uint32_t bidiLevel, winrt::Microsoft::Graphics::Canvas::Text::CanvasTextMeasuringMode const& measuringMode, winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyphOrientation const& glyphOrientation)
    {
        return impl::call_factory<CanvasGeometry, ICanvasGeometryStatics>([&](ICanvasGeometryStatics const& f) { return f.CreateGlyphRun(resourceCreator, point, fontFace, fontSize, glyphs, isSideways, bidiLevel, measuringMode, glyphOrientation); });
    }
    inline auto CanvasGeometry::ComputeFlatteningTolerance(float dpi, float maximumZoomFactor)
    {
        return impl::call_factory<CanvasGeometry, ICanvasGeometryStatics>([&](ICanvasGeometryStatics const& f) { return f.ComputeFlatteningTolerance(dpi, maximumZoomFactor); });
    }
    inline auto CanvasGeometry::ComputeFlatteningTolerance(float dpi, float maximumZoomFactor, winrt::Windows::Foundation::Numerics::float3x2 const& expectedGeometryTransform)
    {
        return impl::call_factory<CanvasGeometry, ICanvasGeometryStatics>([&](ICanvasGeometryStatics const& f) { return f.ComputeFlatteningTolerance(dpi, maximumZoomFactor, expectedGeometryTransform); });
    }
    inline auto CanvasGeometry::DefaultFlatteningTolerance()
    {
        return impl::call_factory_cast<float(*)(ICanvasGeometryStatics const&), CanvasGeometry, ICanvasGeometryStatics>([](ICanvasGeometryStatics const& f) { return f.DefaultFlatteningTolerance(); });
    }
    inline CanvasGradientMesh::CanvasGradientMesh(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatch const> patchElements) :
        CanvasGradientMesh(impl::call_factory<CanvasGradientMesh, ICanvasGradientMeshFactory>([&](ICanvasGradientMeshFactory const& f) { return f.Create(resourceCreator, patchElements); }))
    {
    }
    inline auto CanvasGradientMesh::CreateCoonsPatch(array_view<winrt::Windows::Foundation::Numerics::float2 const> points, array_view<winrt::Windows::Foundation::Numerics::float4 const> colors, array_view<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const> edges)
    {
        return impl::call_factory<CanvasGradientMesh, ICanvasGradientMeshStatics>([&](ICanvasGradientMeshStatics const& f) { return f.CreateCoonsPatch(points, colors, edges); });
    }
    inline auto CanvasGradientMesh::CreateTensorPatch(array_view<winrt::Windows::Foundation::Numerics::float2 const> points, array_view<winrt::Windows::Foundation::Numerics::float4 const> colors, array_view<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMeshPatchEdge const> edges)
    {
        return impl::call_factory<CanvasGradientMesh, ICanvasGradientMeshStatics>([&](ICanvasGradientMeshStatics const& f) { return f.CreateTensorPatch(points, colors, edges); });
    }
    inline CanvasPathBuilder::CanvasPathBuilder(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator) :
        CanvasPathBuilder(impl::call_factory<CanvasPathBuilder, ICanvasPathBuilderFactory>([&](ICanvasPathBuilderFactory const& f) { return f.Create(resourceCreator); }))
    {
    }
    inline CanvasStrokeStyle::CanvasStrokeStyle() :
        CanvasStrokeStyle(impl::call_factory_cast<CanvasStrokeStyle(*)(winrt::Windows::Foundation::IActivationFactory const&), CanvasStrokeStyle>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<CanvasStrokeStyle>(); }))
    {
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometry> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasCachedGeometryStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometry> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGeometryStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMesh> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasGradientMeshStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilder> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathBuilderFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasPathReceiver> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::ICanvasStrokeStyle> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMesh> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasPathBuilder> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
